# 原型
> prototype

## 原型
> 原型是一个对象
![alt](./imgs/prototype-1.png)

* 实例的 proto 指向该对象的构造函数的原型对象，该对象的构造函数的原型对象中定义了共享的属性和方法
* 构造函数的 prototype 指向原型对象
* 原型对象的 constructor 指回构造函数

1. 方法（Function）是对象，方法的原型也(Function.prototype)是对象。因此，它们都会具有对象共有的特点。

> 即：**对象具有属性 __proto__ 或者说 [[prototype]]，可称为隐式原型，一个对象的隐式原型指向构造该对象的构造函数的原型对象，这也保证了实例能够访问在构造函数原型对象中定义的属性和方法。**

2. 方法这个特殊的对象，除了和其他对象一样有上述 _proto_ 属性之外，还有自己特有的属性——原型属性（prototype），**这个属性是一个指针，指向一个对象，这个对象的用途就是包含所有实例共享的属性和方法（我们把这个对象叫做原型对象）。原型对象也有一个属性，叫做 constructor，这个属性包含了一个指针，指回原构造函数。**

分析上图：  
1. 构造函数 Foo()  

> 构造函数的原型属性 Foo.prototype 指向了原型对象，在原型对象里有共有的方法，所有构造函数声明的实例（这里是f1，f2）都可以共享这个方法。

2. 原型对象 Foo.prototype

> Foo.prototype 保存着实例共享的方法，有一个指针 constructor 指回构造函数。

3. 实例

> f1 和 f2 是 Foo 这个对象的两个实例，这两个对象也有属性 __proto__，指向构造函数的原型对象，这样子就可以像上面1所说的访问原型对象的所有方法啦。

构造函数 Foo() 除了是方法，也是对象啊，它也有 __proto__ 属性，指向谁呢？

指向它的**构造函数的原型对象**呗。函数的构造函数不就是Function嘛，因此这里的__proto__指向了 Function.prototype。

其实除了Foo()，Function(), Object()也是一样的道理。

原型对象也是对象啊，它的 __proto__ 属性，又指向谁呢？

同理，指向它的**构造函数的原型对象**呗。这里是 Object.prototype.

最后，Object.prototype 的__proto__属性指向null。

总结：  
1. 对象有属性 __proto__,指向**该对象的构造函数的原型对象**。
2. 方法除了有属性 __proto__,还有属性prototype，prototype指向该方法的原型对象。