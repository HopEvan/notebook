# 数据结构与算法之美
* [概述](#概述)
* [复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗？](#复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗？)
* [复杂度分析（下）：浅析最好、最坏、平均、均摊时间复杂度](#复杂度分析（下）：浅析最好、最坏、平均、均摊时间复杂度)
* [](#)
* [](#)
* [](#)
* [](#)
* [](#)
* [](#)
* [](#)

## 概述
从广义上讲，数据结构就是指一组数据的存储结构。算法就是操作数据的一组方法

比如，因为数组具有随机访问的特点，常用的二分查找算法需要用数组来存储数据。但如果我们选择链表这种数据结构，二分查找算法就就无法工作了，因为链表并不支持随机访问。

![](./imgs/beauty-1.png)

最常用的20个数据结构与算法：
* 数组、链表。栈、队列、散列表、二叉树、堆、跳表、图、Tried树
* 递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法

## 复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗？
### 为什么需要复杂度分析？
事后统计法：把代码跑一遍，通过统计、监控，就能得到正确的算法执行时间和占用内存大小。

缺点：
1. 测试结果依赖测试环境
2. 测试结果受数据规模的影响很大

### 大O复杂度表示法
求1,2,3...n的累加和
```
int cal(int n){
  int sum = 0;
  int i = 1;
  for(;i<=n;++i){
    sum = sum + i;
  }
  return sum;
}
```
第2、3行代码分别需要1个unit_time的执行时间，第4、5行都运行了n遍，所以需要2n*unit_time的执行时间，总得执行时间是(2n+2)*unit_time

所有代码的执行时间 T(n) 与每行代码的执行次数成正比。

```
int cal(int n)[
  int sum = 0;
  int i = 1;
  int j = 1;
  for(;i<=n;i++){
    j=1;
    for(;j<=n;j++){
      sum = sum + i * j;
    }
  }
}
```
我们依旧假设每个语句的执行时间是 unit_time。那这段代码的总执行时间 T(n) 是多少呢？

第 2、3、4 行代码，每行都需要 1 个 unit_time的执行时间，第 5、6 行代码循环执行了 n 遍，需要 2n* unit_time 的执行时间，第 7、8 行代码循环执行了 n^2遍，所以需要 2n^2 * unit_time 的执行时间。所以，整段代码总的执行时间 T(n) = (2n^2+2n+3)*unit_time。

**所有代码的执行时间 T(n) 与每行代码的执行次数成正比。**

> T(n) = O(f(n))

T(n)代表代码执行时间，n代表数据规模的大小，f(n)代表每行代码执行的次数总和。因为这是一个公式，所以用 f(n) 来表示。公式中的 O，表示代码的执行时间 T(n) 与 f(n) 表达式成正比。

第一个例子中的 T(n) = O(2n+2)，第二个例子中的T(n) = O(2n2+2n+3)。这就是大 O 时间复杂表示法。大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度（asymptotic time complexity），简称时间复杂度。

当 n 很大时，你可以把它想象成 10000、100000。而公式中的低阶、常量、系数三部分并不左右增长趋势，所以都可以都可以忽略。我们只需要记录一个最大量级就可以了，如果用大 O表示法表示刚讲的那两段代码的时间复杂度，就可以记为：T(n)= O(n)； T(n) = O(n2)。

### 时间复杂度分析
1. **只关注循环执行次数最多的一段代码（如栗一）**

2. **加法法则：总复杂度等于量级最大的那段代码的复杂度**

```
int cal(int n){
  int sum_1 = 0;
  int p = 1;
  for(;p<100;++p){
    sum_1 = sum_1 + p;
  }

  int sum_2 = 0;
  int q = 1;
  for(;q<n;++q){
    sum_2 = sum_2 + q;
  }

  int sum_3 = 0;
  int i = 1;
  int j = 1;
  for(;i<=n;i++){
    j=1;
    for(;j<=n;j++){
      sum_3 = sum_3 + i * j;
    }
  }

  return sum_1 + sum_2 + sum_3;
}  
```
第一段的时间复杂度是多少呢？这段代码循环执行了 100 次，所以是一个常量的执行时间，跟 n 的规模无关。可以忽略，只要是一个已知的数，都是常量级别的，与n无关。

那第二段代码和第三段代码的时间复杂度是多少呢？答案是 O(n) 和 O(n2)

综合这三段代码的时间复杂度，我们取其中最大的量级。所以，整段代码的时间复杂度就为 O(n2)。也就是说：总的时间复杂度就等于量级最大的那段代码的时间复杂度。

> 如果 T1(n)=O(f(n))，T2(n)=O(g(n))；那么 T(n)=T1(n)+T2(n)=max(O(f(n)), O(g(n))) =O(max(f(n), g(n))).

3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

> 如果 T1(n)=O(f(n))，T2(n)=O(g(n))；那么 T(n)=T1(n) * T2(n)=O(f(n))*O(g(n))=O(f(n)*g(n)).

```
int cal(int n){
  int ret = 0;
  int i = 1;
  for(;i<n;++i){
    ret = ret + f(i);
  }
}

int f(int n){
  int sum = 0;
  int i = 1;
  for(;i<n;++i){
    sum = sum + i;
  }
  return sum;
}
```
单独看 cal() 函数。假设 f() 只是一个普通的操作，那第 4～6 行的时间复杂度就是，T1(n) = O(n)。但 f() 函数本身不是一个简单的操作，它的时间复杂度是 T2(n) = O(n)，所以，整个 cal() 函数的时间复杂度就是，T(n) = T1(n) * T2(n) = O(n*n)= O(n2)。

### 几种常见时间复杂度实例分析

![](./imgs/beauty-2.png)

* 多项式量级
* 非多项式量级：O(2^n)、O(n!)

我们把时间复杂度为非多项式量级的算法问题叫作NP（Non-Deterministic Polynomial，非确定多项式）问题。当数据规模n越来越大时，非多项式时间复杂度的算法其实是非常低效的算法。

1. **O(1)**

O(1) 只是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码。比如这段代码，即便有 3 行，它的时间复杂度也是O(1），而不是 O(3)。

只要代码的执行时间不随n的增大而增长，这样的代码的时间复杂度都记做O(1)。一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上外行代码，其复杂度也是O(1)。

2. **O(logn)、O(nlogn)**
```
i = 1;
while(i<=n){
  i = i * 2;
}
```

![](./imgs/beauty-3.png)

2^x = n

x=log2(n)

时间复杂度：O(log2(n))

```
i = 1;
while(i<=n){
  i = i * 3;
}
```
时间复杂度：O(log3(n))

实际上，不管是以 2 为底、以 3 为底，还是以 10 为底，我们可以把所有对数阶的时间复杂度都记为 O(logn)。为什么呢？

对数之间是可以互相转换的，log3(n)就等于log3(2) * log2(n)，所以 O(log3n) = O(C * log2n)，其中C=log32 是一个常量。在采用大 O 标记复杂度的时候，可以忽略系数，即 O(Cf(n)) = O(f(n))。所以，O(log2n) 就等于 O(log3n)。因此，在对数阶时间复杂度的表示方法里，我们忽略对数的“底”，统一表示为O(logn)。

对于O(nlogn)，如果一段代码的时间复杂度是O(logn)，我们循环执行n遍，时间复杂度就是O(nlogn)。归并排序、快速排序时间复杂度都是O(nlogn)。

3. **O(m+n)、O(m*n)**

```
int cal(int m,int n){
  int sum_1 = 0;
  int i = 1;
  for(;i<m;++i){
    sum_1 = sum_1 + i;
  }

  int sum_2 = 0;
  int j = 1;
  for(;j<n;++j){
    sum_2 = sum_2 + j;
  }

  return sum_1+sum_2;
}
```
从代码中看出，m和b 是表示两个数据规模，无法评估m和n谁的量级大，所以在表示复杂度的时候，就不能简单地利用加法法则，省略其中的一个，因此O(m+n)

针对这种情况更改一下加法法则如下，但是乘法法则不变
> T1(m) + T2(n) = O(f(m) + g(n))

### 空间复杂度分析
空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。

```
void print(int n){
  int i=0;
  int[] a = new int[n];
  for(i;i<n;++i){
    a[i] = i * i;
  }

  for(i=n-1;i>=0;--i){
    print out a[i]
  }
}
```
第 2 行代码中，我们申请了一个空间存储变量 i，但是它是常量阶的，跟数据规模 n 没有关系，所以我们可以忽略。第 3 行申请了一个大小为 n 的 int 类型数组，除此之外，剩下的代码都没有占用更多的空间，所以整段代码的空间复杂度就是O(n)

常见空间复杂度：O(1)、O(n)、O(n^2)

### 内容小结
复杂度也叫渐进复杂度，包括时间复杂度和空间复杂度，用来分析算法执行效率与数据规模之间的增长关系，可以粗略地表示，越高阶复杂度的算法，执行效率越低。常见的复杂度并不多，从低阶到高阶有：O(1)、O(logn)、O(n)、O(nlogn)、O(n2 )

![alt](./imgs/beauty-4.png)

## 复杂度分析（下）：浅析最好、最坏、平均、均摊时间复杂度
### 最好、最坏时间复杂度
```
// n 表示数组array的长度
int find(int[] array,int n,int x){
  int i = 0;
  int pos = -1;
  for(;i<n;++i){
    if(array[i] == x) pos = i;
  }
  return pos;
}
```
这段代码的功能：在一个无序的数组array中，查找变量x出现的位置。如果没有找到，就返回-1。这段代码的复杂度是O(n)，n代表数组长度。

当我们在数组中查找一个数据，不一定要遍历整个数组，可以中途找到就停止。优化一下代码：
```
// n 表示数组array的长度
int find(int[] array,int n,int x){
  int i = 0;
  int pos = -1;
  for(;i<n;++i){
    if(array[i] == x){
      pos = i;
      break;
    }
  }
  return pos;
}
```
如果数组中第一个元素正好是要查找的变量x，那就不需要继续遍历剩下的n-1个数据了，时间复杂度就是O(1)。如果数组中不存在变量x，那我们需要把整个数组都遍历一遍，时间复杂度变成了O(n)。

* 最好时间复杂度：在最理想的情况下，执行这段代码的时间复杂度
* 最坏时间复杂度：在最糟糕的情况下，执行这段代码的时间复杂度

### 平均时间复杂度
要查找的变量 x 在数组中的位置，有 n+1 种情况：在数组的 0～n-1 位置中和不在数组中。我们把每种情况下，查找需要遍历的元素个数累加起来，然后再除以 n+1，就可以得到需要遍历的元素个数的平均值，即：

![alt](./imgs/beauty-5.png)

在时间复杂度的大O表示法中，可以省略掉系数、低阶、常量。所以简化之后，平均时间复杂度为O(n)

这个结论虽然正确，但是计算过程稍微有点问题。刚讲的这n+1种情况，出现的该概率并不是一样的。

比如，要查找的变量x，要么在数组里，要么就不在数组里。这两种情况对应的概率统计起来很麻烦，方便理解，假设在数组中与不在数组中的概率都为1/2。另外，要查找的数据出现在0~n-1这n个位置的概率也是一样的，为1/n。所以，根据概率乘法法则，要找的数据出现在0~n-1中任意位置的概率是1/(2n)

![alt](./imgs/beauty-6.png)

这个值就是概率论中的加权平均值，也叫做期望值，所以平均时间复杂度的全称应该叫做**加权平均时间复杂度**或者**期望时间复杂度**。

引入概率之后，前面那段代码的加权平均值为 (3n+1)/4，用大 O 表示法来表示，去掉系数和常量，这段代码的加权平均时间复杂度仍然是 O(n)。

### 均摊时间复杂度
实际上，在大多数情况下，我们并不需要区分最好、最坏、平均情况时间复杂度三种情况。只有同一块代码在不同的情况下，时间复杂度有量级的差距，我们才会使用这三种复杂度表示法来区分。而均摊时间复杂度应用的场景比它更特殊、更加有限。

```
// n 表示数组array的长度
// 代码中的array.length就等于n

int[] array = new int[n];
int count = 0;

void insert(int val){
  if(count == array.length){
    int sum = 0;
    for(int i = 0;i<array.length;i++){
      sum = sum + array[i];
    }
    array[0] = sum;
    count = 1;
  }
   
  array[count] = val;
  ++count;
}

```